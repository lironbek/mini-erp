import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/prisma";

async function generatePoNumber(): Promise<string> {
  const today = new Date();
  const dateStr = today.toISOString().slice(0, 10).replace(/-/g, "");
  const prefix = `PO-${dateStr}-`;

  const last = await prisma.purchaseOrder.findFirst({
    where: { poNumber: { startsWith: prefix } },
    orderBy: { poNumber: "desc" },
  });

  const seq = last
    ? String(parseInt(last.poNumber.slice(-4)) + 1).padStart(4, "0")
    : "0001";

  return `${prefix}${seq}`;
}

export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { searchParams } = request.nextUrl;
  const status = searchParams.get("status");
  const supplierId = searchParams.get("supplierId");
  const dateFrom = searchParams.get("dateFrom");
  const dateTo = searchParams.get("dateTo");

  const where: Record<string, unknown> = {};
  if (status) where.status = status;
  if (supplierId) where.supplierId = supplierId;
  if (dateFrom || dateTo) {
    where.orderDate = {};
    if (dateFrom) (where.orderDate as Record<string, unknown>).gte = new Date(dateFrom);
    if (dateTo) (where.orderDate as Record<string, unknown>).lte = new Date(dateTo);
  }

  const pos = await prisma.purchaseOrder.findMany({
    where,
    include: {
      supplier: { select: { id: true, name: true, shortName: true } },
      items: {
        include: { rawMaterial: { select: { id: true, sku: true, name: true } } },
      },
      createdBy: { select: { id: true, name: true } },
    },
    orderBy: { createdAt: "desc" },
  });

  return NextResponse.json(pos);
}

export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session || !["ADMIN", "MANAGER", "WAREHOUSE"].includes(session.user.role)) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 403 });
  }

  const body = await request.json();
  const poNumber = await generatePoNumber();

  // Calculate expected delivery date from supplier lead time
  let expectedDeliveryDate = body.expectedDeliveryDate
    ? new Date(body.expectedDeliveryDate)
    : null;

  if (!expectedDeliveryDate && body.supplierId) {
    const supplier = await prisma.supplier.findUnique({
      where: { id: body.supplierId },
    });
    if (supplier) {
      expectedDeliveryDate = new Date();
      expectedDeliveryDate.setDate(
        expectedDeliveryDate.getDate() + supplier.leadTimeDays
      );
      // Adjust for supplier delivery days
      const deliveryDays = (supplier.deliveryDays as number[]) || [];
      if (deliveryDays.length > 0) {
        let attempts = 0;
        while (!deliveryDays.includes(expectedDeliveryDate.getDay()) && attempts < 7) {
          expectedDeliveryDate.setDate(expectedDeliveryDate.getDate() + 1);
          attempts++;
        }
      }
    }
  }

  // Calculate totals
  const items = body.items || [];
  let subtotal = 0;
  for (const item of items) {
    item.totalPrice = (item.quantityOrdered || 0) * (item.unitPrice || 0);
    subtotal += item.totalPrice;
  }

  const po = await prisma.purchaseOrder.create({
    data: {
      poNumber,
      supplierId: body.supplierId,
      status: "draft",
      orderDate: body.orderDate ? new Date(body.orderDate) : new Date(),
      expectedDeliveryDate,
      deliveryTimeSlot: body.deliveryTimeSlot || null,
      subtotal,
      taxAmount: body.taxAmount || 0,
      totalAmount: subtotal + (body.taxAmount || 0),
      currency: body.currency || "SGD",
      notes: body.notes || null,
      autoGenerated: body.autoGenerated || false,
      createdById: session.user.id,
      items: {
        create: items.map(
          (
            item: {
              rawMaterialId: string;
              quantityOrdered: number;
              unit: string;
              unitPrice: number;
              totalPrice: number;
              notes?: string;
            },
            index: number
          ) => ({
            rawMaterialId: item.rawMaterialId,
            quantityOrdered: item.quantityOrdered,
            unit: item.unit || "KG",
            unitPrice: item.unitPrice || null,
            totalPrice: item.totalPrice || null,
            notes: item.notes || null,
            sortOrder: index,
          })
        ),
      },
    },
    include: {
      supplier: { select: { id: true, name: true, shortName: true } },
      items: {
        include: { rawMaterial: { select: { id: true, sku: true, name: true } } },
      },
    },
  });

  return NextResponse.json(po, { status: 201 });
}
